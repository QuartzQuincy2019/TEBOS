<!DOCTYPE html>
<html lang="zh-cn">

<head>
    <meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1">
    <title>Text Encrypter Based On Sanskrit - TEBOS</title>
    <script>
        //database.js
        const consonants = [
            "ट", "ठ", "ड", "ख", "थ", "घ", "ङ", "च", "छ", "फ",//0-9
            "झ", "ञ", "ढ", "त", "र", "ल", "व", "ज", "ग", "द",//10-19
            "ध", "न", "प", "क", "ब", "भ", "म", "य", "स", "ण",//20-29
            "श", "ष"   // 32个辅音字母 (0-31)
        ];
        var extended = [
            //二叠字
            "ट्ट", "ट्ठ", "ट्ख", "ट्च", "ट्छ", "ट्फ", "ट्त", "ट्व", "ट्प", "ट्क", "ट्म", "ट्स", "ट्ण", "ट्श", "ट्ष",
            "ठ्ठ",
            "ड्ड", "ड्घ", "ड्ढ", "ड्ल", "ड्व", "ड्ज", "ड्ग", "ड्द", "ड्ध", "ड्ब", "ड्भ", "ड्म",
            "ङ्ख", "ङ्घ", "ङ्ङ", "ङ्च", "ङ्त", "ङ्व", "ङ्ज", "ङ्ग", "ङ्द", "ङ्ध", "ङ्न", "ङ्प", "ङ्क", "ङ्भ", "ङ्म", "ङ्स", "ङ्श",
            "च्ञ", "छ्व",
            "ञ्च", "ञ्ञ", "ञ्ज",
            "ढ्ढ", "ढ्व",
            "व्न",
            "ज्ञ",
            "द्घ", "द्व", "द्ग", "द्द", "द्ध", "द्न", "द्ब", "द्भ", "द्म", "द्य",
            "ध्न",
            "न्न",
            "प्ट", "प्त", "प्न",
            "क्त", "क्व", "क्न", "क्क", "क्ष",
            "ब्न",
            "भ्न",
            "म्न",
            "श्च", "श्व", "श्न",
            "ष्ट", "ष्ठ",
            //二叠音+r
            "ट्ट्र", "ट्ठ्र", "ट्छ्र", "ट्त्र", "ट्र्र", "ट्प्र", "ट्क्र", "ट्श्र",
            "ठ्ठ्र", "ठ्र्र",
            "ड्ड्र", "ड्घ्र", "ड्ढ्र", "ड्र्र", "ड्ग्र", "ड्ब्र", "ड्भ्र",
            "ङ्घ्र", "ङ्ङ्र", "ङ्त्र", "ङ्र्र", "ङ्व्र", "ङ्ग्र", "ङ्न्र", "ङ्क्र",
            "छ्र्र",
            "ढ्ढ्र", "ढ्र्र",
            "द्घ्र", "द्व्र", "द्ग्र", "द्द्र", "द्ध्र", "द्ब्र", "द्भ्र",
            "न्त्र",
            "प्ट्र", "प्त्र",
            "क्त्र", "क्क्र", "क्ष्र",
            "ष्ट्र", "ष्ठ्र"
        ];
        for (var i = 0; i < consonants.length; i++) {
            extended.push(consonants[i] + "्" + "र");//  Xr  辅音
            //看上去很窄的辅音
            extended.push("त" + "्" + consonants[i]);//  tX  辅音
            extended.push("ग" + "्" + consonants[i]);//  gX  辅音
            extended.push("न" + "्" + consonants[i]);//  nX  辅音
            extended.push("य" + "्" + consonants[i]);//  nX  辅音
        }
        {
            let temp = [];
            for (var i = 0; i < extended.length; i++) {
                temp.push("र" + "्" + extended[i]);// rX(n) 輔音
            }
            extended = extended.concat(temp);
        }
        extended = [...(new Set(extended))];//最小长度：512
        const magnas = consonants.concat(extended);
        const diacritics = [
            "ी", "ू", "ि", "ु", "े", "ा", "ौ", "ो"// 8附标 (0-7)
        ];
        const separators = ["ृ", "्", "ै"];
        const conMap = new Map(consonants.map((char, idx) => [char, idx]));
        const diaMap = new Map(diacritics.map((char, idx) => [char, idx]));
        const magMap = new Map(magnas.map((char, idx) => [char, idx]));

        const rev_con = new Map();
        conMap.forEach((value, key) => {
            rev_con.set(key, value);
        });
        const rev_dia = new Map();
        diaMap.forEach((value, key) => {
            rev_dia.set(key, value);
        });
        const rev_mag = new Map();
        magMap.forEach((value, key) => {
            rev_mag.set(key, value);
        });
        var simplified_C = [];
        for (var i = 0; i < 26; i++) {
            simplified_C.push(String.fromCharCode(65 + i));
        }
        for (var i = 0; i < 26; i++) {
            simplified_C.push(String.fromCharCode(97 + i));
        }
        for (var i = 0; i < 480; i++) {
            simplified_C.push(String.fromCharCode(0x00c0 + i));
        }
        const simMap = new Map(simplified_C.map((char, idx) => [char, idx]));
        const rev_sim = new Map();
        simMap.forEach((value, key) => {
            rev_sim.set(key, value);
        });

        /**
         * G代编码
         * number应为12位（范围 0 ~ 4095）
         */
        function GEncode(binaryString) {
            if (binaryString.length != 12) return;
            const A = parseInt(binaryString.slice(9, 12), 2);
            const C = parseInt(binaryString.slice(0, 9), 2);
            const codeA = diacritics[A];
            const codeC = magnas[C];
            return codeC + codeA;
        }
        function GDecode(cipher) {
            const codeA = cipher.charAt(cipher.length - 1);
            const codeC = cipher.slice(0, cipher.length - 1);
            const A = rev_dia.get(codeA).toString(2).padStart(3, '0');
            const C = rev_mag.get(codeC).toString(2).padStart(9, '0');
            return C + A;
        }




    </script>
    <script>
        //prototypes.js
        Array.prototype.mixUp = function (indexes, element) {
            const validIndexes = [...new Set(indexes)]
                .filter(idx =>
                    Number.isInteger(idx) &&
                    idx >= 0 &&
                    idx < this.length
                );
            validIndexes.sort((a, b) => b - a);
            validIndexes.forEach(idx => {
                this.splice(idx + 1, 0, element);
            });
            return this;
        };
        Array.prototype.deleteAll = function (element) {
            for (let i = this.length - 1; i >= 0; i--) {
                if (this[i] === element) {
                    this.splice(i, 1);
                }
            }
            return this;
        };
        String.prototype.divideForward = function (identifiers) {
            const idSet = new Set(identifiers);
            const result = [];
            let start = 0;
            let current = 0;
            while (current < this.length) {
                if (idSet.has(this[current])) {
                    result.push(this.slice(start, current + 1));
                    start = current + 1;  // 更新起始位置
                }
                current++;
            }
            if (start < current) {
                result.push(this.slice(start));
            }

            return result;
        };
    </script>
    <script>
        //进制转换。输入(2180,10)得到[0,8,1,2]。
        function convertToBaseArray(num, base) {
            if (num === 0) return [0];
            const digits = [];
            while (num > 0) {
                const remainder = num % base;
                digits.push(remainder);
                num = Math.floor(num / base);
            }
            return digits;
        }

        function calculateK(blockSize) {
            return Math.ceil(Math.log2(2 * blockSize));
        }

        /**
         * PKCS7按位填充
         * @param {string} bitString 二进制字符串（由'0'和'1'组成）
         * @param {number} blockSize 块大小（位）
         * @returns {string} 填充后的二进制字符串
         */
        function bitPKCS7Pad(bitString, blockSize) {
            if (bitString == '') {
                return '0'.repeat(blockSize);
            };
            if (blockSize < 1 || blockSize == undefined) throw new Error("Block size must be at least 1");
            const len = bitString.length;
            // 计算最小填充位数
            const remainder = len % blockSize;
            const P_min = remainder === 0 ? blockSize : blockSize - remainder;
            const K = calculateK(blockSize);

            // 确定总填充位数
            let P_total = P_min;
            if (P_min < K + 1) {
                P_total = P_min + blockSize;
            }

            // 生成填充内容：前导0 + 总填充位数的二进制表示
            const padZeros = '0'.repeat(P_total - K);
            const padCount = P_total.toString(2).padStart(K, '0');
            return bitString + padZeros + padCount;
        }

        /**
         * PKCS7按位去填充
         * @param {string} bitString 填充后的二进制字符串
         * @param {number} blockSize 块大小（位）
         * @returns {string} 原始二进制字符串
         */
        function bitPKCS7Unpad(bitString, blockSize) {
            if (blockSize < 1) throw new Error("Block size must be at least 1");
            const len = bitString.length;
            const K = calculateK(blockSize);
            // if (len < K) throw new Error("Bit string too short");

            // 解析总填充位数
            const padCountBits = bitString.substring(len - K);
            const P_total = parseInt(padCountBits, 2);
            // if (P_total < 1 || P_total > 2 * blockSize - 1) {
            //     throw new Error("Invalid padding length");
            // }
            // if (len < P_total) throw new Error("Padding exceeds bit string length");

            // 验证并移除填充位
            const padStart = len - P_total;
            const zeros = bitString.substring(padStart, padStart + P_total - K);
            // if (!/^0*$/.test(zeros)) {
            //     throw new Error("Non-zero bits in padding");
            // }
            return bitString.substring(0, padStart);
        }



        /**
         * 字符串分组
         * @param {string} str "andyouare"
         * @param {number} n 3
         * @returns ["and","you","are"]
         */
        function splitIntoChunks(str, n) {
            const result = [];
            for (let i = 0; i < str.length; i += n) {
                result.push(str.substring(i, i + n));
            }
            return result;
        }
        function paveWay(arr, target) {
            // 记录所有需要删除的索引位置
            const indicesToDelete = new Set();
            for (let i = 0; i < arr.length; i++) {
                if (arr[i] === target && i > 0) {
                    if (arr[i - 1] !== target) {
                        indicesToDelete.add(i - 1);
                    }
                }
            }
            const sortedIndices = Array.from(indicesToDelete).sort((a, b) => b - a);
            for (const index of sortedIndices) {
                arr.splice(index, 1);
            }
            return arr;
        }
        /**
         * 
         * @param {array} bytes 给出UTF-8的编码：[228, 184, 173]，返回对应Unicode字符。
         * @returns 
         */
        function getCharFromUTF8Bytes(bytes) {
            const decoder = new TextDecoder('utf-8');
            return decoder.decode(new Uint8Array(bytes));
        }

        /**
         * 
         * @param {string} char 获取单个字符的UTF-8编码
         * @returns 
         */
        function getUTF8Bytes(char) {
            const encoder = new TextEncoder();
            return Array.from(encoder.encode(char));
        }
        //Deva-Mb12E加密系统
        function Deva_Mb12E(text) {
            const encoder = new TextEncoder();
            let binaryStr = encoder.encode(text);
            let bytes = [...binaryStr];
            bytes = bytes.map((byte) => byte.toString(2).padStart(8, '0'));
            bytes = bitPKCS7Pad(bytes.join(""), 12);
            let converted = splitIntoChunks(bytes, 12);
            var ciphers = [];
            for (block of converted) {
                ciphers.push(GEncode(block));
            }
            return ciphers.join("");
        }
        function de_Mb12E(ciphers) {
            ciphers = ciphers.divideForward(diacritics);
            ciphers = ciphers.map(cipher => GDecode(cipher));
            ciphers = ciphers.join("");
            var plaintext = bitPKCS7Unpad(ciphers, 12);
            plaintext = splitIntoChunks(plaintext, 8);
            plaintext = plaintext.map(byte => parseInt(byte, 2));
            var uarr = new Uint8Array(plaintext);
            let decoder = new TextDecoder();
            return decoder.decode(uarr);
        }
        //Latin-SbN加密系统
        const Latin_SbN_base = 512;
        function Latin_SbN(text, N) {
            //位数设为N，基数设为512进制
            const encoder = new TextEncoder();
            let binaryStr = encoder.encode(text);
            let bytes = [...binaryStr];
            bytes = bytes.map((byte) => byte.toString(2).padStart(8, '0'));
            bytes = bitPKCS7Pad(bytes.join(""), N);
            let converted = splitIntoChunks(bytes, N);
            var ciphers = [];
            for (block of converted) {
                let number = parseInt(block, 2);
                let arr = convertToBaseArray(number, Latin_SbN_base);
                let Cs = "";
                for (var d = arr.length - 1; d >= 0; d--) {
                    Cs += simplified_C[arr[d]];
                }//从高位到低位编字符，字符展示为高位向低位
                let cipher = Cs;
                ciphers.push(cipher, " ");
            }
            ciphers.pop();
            return ciphers.join("");
        }
        function de_SbN(ciphers, N) {
            ciphers = ciphers.split(" ");
            var plaintext = [];
            for (cipher of ciphers) {
                var Cs = [];
                for (C of cipher) {
                    Cs.push(rev_sim.get(C));
                }//此时Cs从高位到低位
                Cs = Cs.reverse();
                let sum = 0;
                for (var d = 0; d < Cs.length; d++) {
                    sum += Cs[d] * Math.pow(Latin_SbN_base, d);
                }
                var number = sum;
                number = number.toString(2).padStart(N, '0');
                plaintext.push(number);
            }
            plaintext = plaintext.join("");
            plaintext = bitPKCS7Unpad(plaintext, N);
            plaintext = splitIntoChunks(plaintext, 8);
            plaintext = plaintext.map(cipher => parseInt(cipher, 2));
            var uarr = new Uint8Array(plaintext);
            let decoder = new TextDecoder();
            return decoder.decode(uarr);
        }
        //Deva-F40bN加密系统
        function Deva_F40bN(text, N) {
            const encoder = new TextEncoder();
            let binaryStr = encoder.encode(text);// 1.编码字符
            let bytes = [...binaryStr];
            bytes = bytes.map((byte) => byte.toString(2).padStart(8, '0'));// 2.转化为二进制字符串数组
            bytes = bitPKCS7Pad(bytes.join(""), N);// 3.&4. join和PKCS
            let converted = splitIntoChunks(bytes, N);// 5.N分组
            var ciphers = []
            for (block of converted) {// 6.转换
                let number = parseInt(block, 2);
                let A = diacritics[number % 8];//元音
                let arr = convertToBaseArray((number - number % 8) / 8, 32);//8倍数用32进制表示
                let Cs = "";
                for (var d = arr.length - 1; d >= 0; d--) {
                    Cs += consonants[arr[d]];
                    if (d != 0) {
                        Cs += "्";
                    }
                }
                let cipher = Cs + A;
                ciphers.push(cipher, " ");
            }
            ciphers.pop();//删除末尾空格
            return ciphers.join("");
        }
        function de_F40bN(ciphers, N) {
            // 6.逆转换
            ciphers = ciphers.split("").deleteAll(" ").join("");
            ciphers = ciphers.divideForward(diacritics);
            var plaintext = [];
            for (cipher of ciphers) {
                const len = cipher.length;
                var A = rev_dia.get(cipher[len - 1]);
                var Cs = [];
                Cs.push(rev_con.get(cipher[len - 2]));
                for (i = 4; i <= len; i += 2) {
                    if (len >= i) Cs.push(rev_con.get(cipher[len - i]));
                }
                // console.log(Cs);
                //// if (len >= 16) Cs.push(rev_con.get(cipher[len - 16]));
                let sum = 0;
                for (var d = 0; d < Cs.length; d++) {
                    sum += Cs[d] * Math.pow(32, d);
                }
                var number = sum * 8 + A;
                number = number.toString(2).padStart(N, '0');//18位
                plaintext.push(number);
            }
            //现在plaintext中是18位字符串数组
            plaintext = plaintext.join("");
            //现在plaintext是一个长度为18整数倍的二进制字符串
            plaintext = bitPKCS7Unpad(plaintext, N);
            plaintext = splitIntoChunks(plaintext, 8);
            //现在plaintext被分割为8位的二进制字符串
            plaintext = plaintext.map(cipher => parseInt(cipher, 2));
            var uarr = new Uint8Array(plaintext);
            let decoder = new TextDecoder();
            return decoder.decode(uarr);
        }
        //Deva-B32p8加密系统
        function Deva_B32p8(text) {
            const encoder = new TextEncoder();
            let binaryStr = encoder.encode(text);
            var bytes = [...binaryStr];
            bytes = bytes.map(byte => byte.toString(2).padStart(8, '0'));
            var ciphers = [];
            for (var i = 0; i < bytes.length; i++) {
                let integer = parseInt(bytes[i], 2);
                const char2 = diacritics[integer % 8];
                const char1 = consonants[(integer - integer % 8) / 8];
                const char = char1 + char2;
                ciphers.push(char1 + char2);
            }
            var lastSpace = 0;
            var indexes = [];
            for (var i = 0; i < ciphers.length; i++) {
                if (i - lastSpace >= 2 && ciphers.length - i >= 2) {
                    if (Math.random() >= 0.4) {
                        indexes.push(i);
                        lastSpace = i;
                    }
                }
            }
            ciphers.mixUp(indexes, " ");
            return ciphers.join("");
        }
        function de_B32p8(ciphers) {
            ciphers = ciphers.split("");
            ciphers.deleteAll(" ");
            console.log(ciphers);
            var u = new Array();
            for (var i = 0; i < ciphers.length;) {
                let C1 = rev_con.get(ciphers[i]);
                let A1 = rev_dia.get(ciphers[i + 1]);
                res = C1 * 8 + A1;
                i += 2;
                u.push(res);
            }
            console.log(u);
            let decoder = new TextDecoder();
            var bytes = new Uint8Array(u);
            return decoder.decode(bytes);
        }
        //Deva_D32p8M加密系统
        function Deva_D32p8M(text) {
            var ciphers = [];
            for (const char of text) {
                var cipher = "";
                var char_result = [];
                const bytes = getUTF8Bytes(char);
                for (const byte of bytes) {
                    const char2 = diacritics[byte % 8];
                    const char1 = consonants[(byte - byte % 8) / 8];
                    const char = char1 + char2;
                    // console.log(char);
                    char_result.push(char1 + char2);
                }
                char_result.push(consonants[Math.floor(Math.random() * consonants.length)] + separators[Math.floor(Math.random() * separators.length)]);
                cipher = char_result.join("");
                ciphers.push(cipher);
            }
            ciphers = ciphers.join("").split("");
            var lastSpace = 0;
            var indexes = [];
            for (var i = 0; i < ciphers.length; i++) {
                if (i - lastSpace >= 2 && i % 2 == 1 && ciphers.length - i >= 2) {
                    if (Math.random() >= 0.4) {
                        indexes.push(i);
                        lastSpace = i;
                    }
                }
            }
            ciphers.mixUp(indexes, " ");
            return ciphers.join("");
        }
        function de_D32p8M(ciphers) {
            var ciphers_set = ciphers.split("");
            ciphers_set.deleteAll(" ");
            ciphers_set = paveWay(ciphers_set, separators[0]);
            ciphers_set = paveWay(ciphers_set, separators[1]);
            ciphers_set = paveWay(ciphers_set, separators[2]);
            ciphers_set = ciphers_set.join("").split(separators[0])
                .join("").split(separators[1])
                .join("").split(separators[2]);
            var plaintext = [];
            for (cipher of ciphers_set) {
                var bytes = [];
                var res = 0;
                const units = splitIntoChunks(cipher, 2);
                for (unit of units) {
                    let C1 = rev_con.get(unit[0]);
                    let A1 = rev_dia.get(unit[1]);
                    res = C1 * 8 + A1;
                    bytes.push(res);
                }
                plaintext.push(getCharFromUTF8Bytes(bytes));
            }
            return plaintext.join("");
        }

        var MODE = 'Deva-Mb12E';
        function encrypt(text, mode = 'Deva-Mb12E') {
            var ciphers = [];
            if (mode == 'Deva-Mb12E') ciphers = Deva_Mb12E(text);
            if (mode == 'Deva-F40b18') ciphers = Deva_F40bN(text, 18);
            if (mode == 'Deva-F40b38') ciphers = Deva_F40bN(text, 38);
            if (mode == 'Deva-B32p8') ciphers = Deva_B32p8(text);
            if (mode == 'Deva-D32p8M') ciphers = Deva_D32p8M(text);
            if (mode == 'Latin-Sb32B512') ciphers = Latin_SbN(text, 32);
            return ciphers
        }

        function decrypt(ciphers, mode = 'Deva-Mb12E') {
            if (mode == 'Deva-Mb12E') return de_Mb12E(ciphers);
            if (mode == 'Deva-F40b18') return de_F40bN(ciphers, 18);
            if (mode == 'Deva-F40b38') return de_F40bN(ciphers, 38);
            if (mode == 'Deva-B32p8') return de_B32p8(ciphers);
            if (mode == 'Deva-D32p8M') return de_D32p8M(ciphers);
            if (mode == 'Latin-Sb32B512') return de_SbN(ciphers, 32);
        }
    </script>
    <style>
        :root {
            --bg-color: #000000;
            --text-color: #ffffff;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
        }

        * {
            font-family: 'Times New Roman', Times, serif;
            transition: background-color 0.3s, color 0.3s;
        }

        textarea {
            display: block;
            width: 100%;
            box-sizing: border-box;
            background-color: var(--bg-color);
            color: var(--text-color);
            padding: 0.4em;
            font-family: 'Sanskrit Text','Times New Roman', Times, serif;
        }

        .input {
            min-height: 8em;
            font-size: 2.2em;
        }

        .results {
            box-sizing: border-box;
            border: 4px solid var(--text-color);
            padding: 0.2em;
            border-radius: 10px;
            font-size: 2.2em;
            overflow-wrap: break-word;
        }

        .sanskrit {
            font-family: 'Sanskrit Text', 'Times New Roman';
        }

        .plain.results {
            min-height: 10em;
        }

        .sanskrit.results {
            min-height: 10em;
        }

        button {
            color: #000;
            font-size: 1.8em;
            padding: 0.4em;
            margin: 0.2em;
        }

        form {
            color: #63e115;
            text-shadow: 1px 1px 0px #000;
            font-size: 2em;
        }

        form .recommended{
            color: #efae16;
            text-shadow: 1px 1px 0px #ff7d78, -1px -1px 1px #cccccc;
        }

        a {
            text-decoration: none;
            font-weight: 1000;
            color: #ff6ac1;
        }

        a:visited {
            color: #ff6ac1;
        }
    </style>
</head>

<body>
    <h1>Text Encrypter Based On Sanskrit - TEBOS</h1>
    <h3>Author: QuartzStudio2019(Quincy K.) &copy;2019-2025 - All Rights Reserved</h3>
    <p>设备须支持天城文(Devanagari)显示。若装载Sanskrit Text字体，体验更佳。</p>
    <h3>v5.0.0</h3>
    <button title="切换色调" onclick="changeSkin();">切换色调</button>
    <p>经TEBOS加密后的密文是无意义但可读的。可前往<a title="Sanskrit Transliteration Tool" target="_blank"
            href="https://www.yesvedanta.com/transliterate/">梵语转写工具网站</a>，参考"IAST"栏来查询密文的读音。</p>
    <h2>加密算法选择</h2>
    <form id="AlgorithmSelection">
        <input type="radio" id="Algo_Mb12E" name="加密算法" value="Deva-Mb12E" checked />
        <label for="Algo_Mb12E" class="recommended">Deva-Mb12E</label>
        <br>
        <input type="radio" id="Algo_Sb32B512" name="加密算法" value="Latin-Sb32B512" />
        <label for="Algo_Sb32B512">Latin-Sb32B512</label>
        <br>
        <input type="radio" id="Algo_F40b18" name="加密算法" value="Deva-F40b18" />
        <label for="Algo_F40b18">Deva-F40b18</label>
        <br>
        <input type="radio" id="Algo_F40b38" name="加密算法" value="Deva-F40b38" />
        <label for="Algo_F40b38">Deva-F40b38</label>
        <br>
        <input type="radio" id="Algo_B32p8" name="加密算法" value="Deva-B32p8" />
        <label for="Algo_B32p8">Deva-B32p8</label>
        <br>
        <input type="radio" id="Algo_D32p8M" name="加密算法" value="Deva-D32p8M" />
        <label for="Algo_D32p8M">Deva-D32p8M</label>
    </form>
    <p>Deva-Mb12E：信息最密集，极限压缩，密文最短。12位、8进制、超大映射加密，无掩码，计算较快。</p>
    <p>Latin-Sb32B512：信息更密集，密文很短。32位、512进制超大映射加密，无掩码，计算较慢。</p>
    <p>Deva-F40b18：信息更密集，无掩码。Deva-F40b38：计算更慢，密文相对更短，无掩码。两算法以32*8进制进行加密，逻辑相同。</p>
    <p>Deva-B32p8：信息不密集，计算更快，无掩码。Deva-D32p8M：密文相对更长，有掩码。两算法基本逻辑相同。</p>
    <hr>
    <h1>解密 - Decrypt</h1>
    <textarea title="解密" id="decoding" class="sanskrit input"></textarea>
    <button title="复制" onclick="copyPlaintext();">复制明文</button>
    <textarea title="明文" id="plaintext" class="results plain" readonly>---Plaintext---</textarea>
    <hr>
    <h1>加密 - Encrypt</h1>
    <textarea title="加密" id="encoding" class="plain input"></textarea>
    <button title="复制" onclick="copyCipher();">复制密文</button>
    <textarea title="密文" id="cipher" class="results sanskrit" readonly>---Cipher---</textarea>
    <script>
        function de() {
            document.getElementById("plaintext").value = decrypt(document.getElementById("decoding").value, MODE);
        }
        function en() {
            document.getElementById("cipher").value = encrypt(document.getElementById("encoding").value, MODE);
        }
        document.getElementById("decoding").addEventListener("input", () => {
            de();
        });
        document.getElementById("encoding").addEventListener("input", () => {
            en();
        });
        function copyPlaintext() {
            navigator.clipboard.writeText(document.getElementById("plaintext").value);
        }
        function copyCipher() {
            navigator.clipboard.writeText(document.getElementById("cipher").value);
        }
    </script>
    <script>
        var skin = 'dark';
        function changeSkin() {
            if (skin == 'dark') {
                document.documentElement.style.setProperty("--bg-color", "#ffffff");
                document.documentElement.style.setProperty("--text-color", "#000000");
                skin = 'light';
            } else {
                document.documentElement.style.setProperty("--bg-color", "#000000");
                document.documentElement.style.setProperty("--text-color", "#ffffff");
                skin = 'dark';
            }
        }
        document.getElementById("AlgorithmSelection").addEventListener('change', () => {
            if (document.getElementById("Algo_Mb12E").checked === true) MODE = 'Deva-Mb12E';
            if (document.getElementById("Algo_F40b18").checked === true) MODE = 'Deva-F40b18';
            if (document.getElementById("Algo_F40b38").checked === true) MODE = 'Deva-F40b38';
            if (document.getElementById("Algo_B32p8").checked === true) MODE = 'Deva-B32p8';
            if (document.getElementById("Algo_D32p8M").checked === true) MODE = 'Deva-D32p8M';
            if (document.getElementById("Algo_Sb32B512").checked === true) MODE = 'Latin-Sb32B512';
            de(); en();
        })
    </script>
</body>

</html>